# オブジェクト指向
## 三大要素　カプセル化、継承、ポリモーフィズム
1. カプセル化について
カプセル化をしない場合
空の配列を作り、変数ポケモンに代入。
捕まえたポケモンはハッシュで管理し、配列に入れていきます。
```ruby
#---------------------カプセル化をしない場合-------------------------------------
ポケモン = [] #空の配列を作り、変数ポケモンに代入。
#---------------------ポケモンのデータを作成する。ハッシュと配列を使う---------------
#ハッシュでポケモンを作成し、配列に代入。 プレイヤーは種族値（「こうげき」などの数値）を変更することができない。
ポケモン << { なまえ: 'ピカチュウ', hp: 35, こうげき: 55, ぼうぎょ: 40, とくこう: 50, とくぼう: 50, すばやさ: 90 }
ポケモン << { なまえ: 'フジギダネ', hp: 45, こうげき: 49, ぼうぎょ: 49, とくこう: 65, とくぼう: 65, すばやさ: 45 }

#捕まえたしたポケモンを表示する。
ポケモン.each do |モンスターボール|
  puts "なまえ: #{モンスターボール[:なまえ]} こうげき:#{モンスターボール[:こうげき]}  ぼうぎょ:#{モンスターボール[:ぼうぎょ]} とくこう:#{モンスターボール[:とくこう]} とくぼう:#{モンスターボール[:とくぼう]} すばやさ:#{モンスターボール[:すばやさ]}"
end
```
実行結果
```ruby
なまえ: ピカチュウ こうげき:55  ぼうぎょ:40 とくこう:50 とくぼう:50 すばやさ:90
なまえ: フジギダネ こうげき:49  ぼうぎょ:49 とくこう:65 とくぼう:65 すばやさ:45
```
勝手に値を変更したり、勝手に新しいキーと値を追加できます。
本来、変更できない種族値の値を変更できてしまいます。
しかも、勝手に武器を持たせることができてしまいます。
```ruby
#---------------------カプセル化をしない場合-------------------------------------
ポケモン = [] #空の配列を作り、変数ポケモンに代入。
#---------------------ポケモンのデータを作成する。ハッシュと配列を使う---------------
#ハッシュでポケモンを作成し、配列に代入。 プレイヤーは種族値（「こうげき」などの数値）を変更することができない。
ポケモン << { なまえ: 'ピカチュウ', hp: 35, こうげき: 55, ぼうぎょ: 40, とくこう: 50, とくぼう: 50, すばやさ: 90 }
ポケモン << { なまえ: 'フジギダネ', hp: 45, こうげき: 49, ぼうぎょ: 49, とくこう: 65, とくぼう: 65, すばやさ: 45 }

#--------------------作成したポケモンの値を勝手に変更する。--------------------------
#‼️ピカチュウの種族値「こうげき」を勝手に変更‼️
ポケモン[0][:こうげき] = 100
puts "勝手に種族値を変更した#{ポケモン[0][:なまえ]}の ❗️こうげき:#{ポケモン[0][:こうげき]}❗️ ぼうぎょ:#{ポケモン[0][:ぼうぎょ]} とくこう:#{ポケモン[0][:とくこう]} とくぼう:#{ポケモン[0][:とくぼう]} すばやさ:#{ポケモン[0][:すばやさ]}"

#‼️勝手にピカチュウに持ち物を持たせる‼️(勝手に新しいキーと値を作成した)
ポケモン[0][:もちもの] = '拳銃'
puts "勝手に持ち物を持たせた#{ポケモン[0][:なまえ]}の ❗️こうげき:#{ポケモン[0][:こうげき]}❗️ ぼうぎょ:#{ポケモン[0][:ぼうぎょ]} とくこう:#{ポケモン[0][:とくこう]} とくぼう:#{ポケモン[0][:とくぼう]} すばやさ:#{ポケモン[0][:すばやさ]} もちもの: ❗️#{ポケモン[0][:もちもの]}❗️"
```

実行結果
```ruby
勝手に種族値を変更したピカチュウの ❗️こうげき:100❗️ ぼうぎょ:40 とくこう:50 とくぼう:50 すばやさ:90
勝手に持ち物を持たせたピカチュウの ❗️こうげき:100❗️ ぼうぎょ:40 とくこう:50 とくぼう:50 すばやさ:90 もちもの: ❗️拳銃❗️
```
カプセル化をした場合
class として定義することによってカプセル化することができます。
```ruby
class Pikachu #-------カプセル　ここから 😎---------------------

  #ピカチュウが持つ種族値を定義している。
  def initialize(なまえ)
    @なまえ = なまえ
    @hp = 35
    @こうげき = 55
    @ぼうぎょ = 40
    @とくこう = 50
    @とくぼう = 50
    @すばやさ = 90
  end
end #-----------------カプセル　ここまで 😎----------------

モンスターボール = Pikachu.new('ピカチュウ') #トレーナーは、ピカチュウに名前を付けることができる。
p モンスターボール #モンスターボール（変数）の中には、ピカチュウ（インスタンス）が入っている。
```
```ruby
initialize は Pikachu.new をすると自動で呼び出されるメソッド。
これにより、インスタンスに初期値を与えている。
initialize が無ければ、Pikachu.new した際に、何も値がないインスタンスが生成される。
```
実行結果
```ruby
<Pikachu:0x0000000104937588 @なまえ="ピカチュウ", @hp=35, @こうげき=55, @ぼうぎょ=40, @とくこう=50, @とくぼう=50, @すばやさ=90>
```
試しに、値を変更しようとしてみます。
NoMethodError が出て、変更できないことが確認できます。
```ruby
class Pikachu #-------カプセル　ここから 😎---------------------
  
  #ピカチュウが持つ種族値を定義している。
  def initialize(なまえ)
    @なまえ = なまえ
    @hp = 35
    @こうげき = 55
    @ぼうぎょ = 40
    @とくこう = 50
    @とくぼう = 50
    @すばやさ = 90
  end
end #-----------------カプセル　ここまで 😎----------------

#---------「なまえ」を変更しようとするが、エラーになる------------
モンスターボール = Pikachu.new('ピカチュウ') #トレーナーは、ピカチュウに名前を付けることができる。
モンスターボール.なまえ = '範馬 勇次郎'
```
実行結果
```ruby
undefined method `なまえ=' for <Pikachu:0x000000010c2ada70 @なまえ="ピカチュウ", @hp=35, @こうげき=55, @ぼうぎょ=40, @とくこう=50, @とくぼう=50, @すばやさ=90> (NoMethodError)
```
種族値は、変更できないが、「なまえ」は変更できるようにしたい、、、
そこで登場するのがゲッターとセッターです。
```ruby
attr_accessor はゲッターとセッターを定義。

attr_reader はゲッターを定義。

attr_writer はセッターを定義。
```
内部的にはどうなっているの？
```ruby
attr_reader :なまえ 　とした場合。（ゲッター）

def なまえ
  @なまえ
end
```
```ruby
attr_writer :なまえ　　とした場合。（セッター）

def なまえ=(なまえ)
  @なまえ = なまえ
end
```
```ruby
attr_accessor :なまえ　　（ゲッターとセッター両方）

def なまえ
  @なまえ
end

def なまえ=(なまえ)
  @なまえ = なまえ
end
```
先程のエラーは
```ruby
undefined method `なまえ=' (NoMethodError)
```
ゲッターとセッターを使えば、「なまえ」というメソッドが定義される！
ピカチュウクラスにゲッターとセッターを作成する。
```ruby
class Pikachu #-------カプセル　ここから 😎---------------------
  attr_reader :hp, :こうげき, :ぼうぎょ, :とくこう, :とくぼう, :すばやさ #読み取りのみを許可している（セッター）
  attr_accessor :なまえ #読み取りと書き込みを許可している（ゲッターとセッター）

  #ピカチュウが持つ種族値を定義している。
  def initialize(なまえ)
    @なまえ = なまえ
    @hp = 35
    @こうげき = 55
    @ぼうぎょ = 40
    @とくこう = 50
    @とくぼう = 50
    @すばやさ = 90
  end
end #-----------------カプセル　ここまで 😎----------------

#-----------------ピカチュウを捕まえた!!----------------
モンスターボール = Pikachu.new('ピカチュウ') #トレーナーは、ピカチュウに名前を付けることができる。
p モンスターボール #モンスターボール（変数）の中には、ピカチュウ（インスタンス）が入っている。

#----------「なまえ」は自由に変更することができる-------------
#インスタンスの「なまえ」を変更している。（「attr_accessor :なまえ」の記述があるため、変更可能)
モンスターボール.なまえ = '範馬 勇次郎'
p モンスターボール

#-----------種族値「こうげき」を変更しようとするが、変更することができない-----
# インスタンスの「こうげき」を変更するが、エラーになる。（「attr_reader :こうげき」の記述があるため、読み取りのみ可能）
モンスターボール.こうげき = 90
p モンスターボール
```
​
実行結果
```ruby
<Pikachu:0x000000010b97dcc0 @なまえ="ピカチュウ", @hp=35, @こうげき=55, @ぼうぎょ=40, @とくこう=50, @とくぼう=50, @すばやさ=90>

<Pikachu:0x000000010b97dcc0 @なまえ="範馬 勇次郎", @hp=35, @こうげき=55, @ぼうぎょ=40, @とくこう=50, @とくぼう=50, @すばやさ=90>

 undefined method `こうげき=' for <Pikachu:0x000000010b97dcc0 @なまえ="ピカ", @hp=35, @こうげき=55, @ぼうぎょ=40, @とくこう=50, @とくぼう=50, @すばやさ=90> (NoMethodError)
```
「なまえ」は変更できるが、「種族値」は変更不可にできました！
## 2.継承について
ポケモンをオブジェクトとして捉えると、どのポケモンも構造は同じです。
伝説のポケモンと、その辺の草むらにいるキャタピー（笑）を比較しても、「なまえ」を持ち、「種族値」を持っていることには変わりありません。
伝説のポケモンだけ、魔法が使えて、種族値にマジックポイントが設定されている、というものではありませんよね。
なので、共通するものについては、親クラスに定義し、親クラスを継承するという設計にしましょう。
「親クラス」は「スーパークラス」ともいいます。
「子クラス」は「サブクラス」ともいいます。
性質や概念が共通しているか、クラスの継承が適切なのかを判断する方法として「is-aの関係」というものがあります。
例：サブクラスはスーパークラスの一種である。（サブクラス is a スーパークラス）
例：ピカチュウはポケモンの一種である。（ピカチュウ is a ポケモン）
余談ですが、継承関係にあるのかを確認する場合「  is_a?  」というメソッドがあります。
```ruby
ピカチュウ.is_a?(ポケモン)   #=> tru
```
それでは、スーパークラス Pokemon を作成しましょう。
```ruby
class Pokemon #親クラスのとなる Pokemonクラスを定義する。
  attr_reader :hp, :こうげき, :ぼうぎょ, :とくこう, :とくぼう, :すばやさ #読み取りのみを許可している（セッター）
  attr_accessor :なまえ #読み取りと書き込みを許可している（ゲッターとセッター）

  #ポケモンが持つ基本的なステータスを定義している。
  def initialize(なまえ:, hp:, こうげき:, ぼうぎょ:, とくこう:, とくぼう:, すばやさ:)
    @なまえ = なまえ
    @hp = hp
    @こうげき = こうげき
    @ぼうぎょ = ぼうぎょ
    @とくこう = とくこう
    @とくぼう = とくぼう
    @すばやさ = すばやさ
  end

  def ステータス #ポケモンのステータスを表示させるメソッドを定義
    <<-STATUS
      [#{@なまえ}のステータス]
      HP: #{@hp}
      こうげき: #{@こうげき}
      ぼうぎょ: #{@ぼうぎょ}
      とくこう: #{@とくこう}
      とくぼう: #{@とくぼう}
      すばやさ: #{@すばやさ}
    STATUS
  end
end
```

Pikachu クラスに Pokemon クラスを継承させましょう。
```ruby
require_relative 'pokemon' #pokemon.rbを読み込んでいる。

class Pikachu < Pokemon # Pokemonクラスを継承している。「is-aの関係」 Pikachu is a Pokemon ピカチュウはポケモンの一種である。
  #ピカチュウのステータスを定数で定義している。
  DEFAULT_STATUS = {
    hp: 35,
    こうげき: 55,
    ぼうぎょ: 40,
    とくこう: 50,
    とくぼう: 50,
    すばやさ: 90,
  }

  #インスタンスの初期値を設定している。
  #「なまえ」DEFAULT_STATUSで定義しておらず、読み取り、書き込み可能にしている。Pikachu.new の引数で「なまえ」を受け取っている。
  def initialize(なまえ)
    super(
      なまえ: なまえ, #変更"可能"
      hp: DEFAULT_STATUS[:hp], #変更不可
      こうげき: DEFAULT_STATUS[:こうげき], #変更不可
      ぼうぎょ: DEFAULT_STATUS[:ぼうぎょ], #変更不可
      とくこう: DEFAULT_STATUS[:とくこう], #変更不可
      とくぼう: DEFAULT_STATUS[:とくぼう], #変更不可
      すばやさ: DEFAULT_STATUS[:すばやさ], #変更不可
    )
  end
end

モンスターボール = Pikachu.new('ピカチュウ')
puts モンスターボール.ステータス #Pokemonクラスで定義した「ステータス」メソッド
```
実行結果
```ruby
      [ピカチュウのステータス]
      HP: 35
      こうげき: 55
      ぼうぎょ: 40
      とくこう: 50
      とくぼう: 50
      すばやさ: 90
```
結局、継承させることで何が嬉しいの？？
それは　”変更に強くなる “　という点です。
現在、確認されているポケモンの総数は 1025種類です。
ポケモン１種類につき、１つのクラスを作成するとします。
すると、1025 個のクラスを作成することとなります。
そして、ポケモンに「持ち物をもたせる」という仕様を追加するとします。
1025 個のクラスに対し、「持ち物をもたせる」というコードを追記しなくてはなりません。
そこで、1025 個のクラスに、スーパークラス Pokemon を継承させましょう。
そうすることにより「持ち物をもたせる」というコードの追記は、Pokemon クラスのみで実装可能となります。
```ruby
class Pokemon
  attr_reader :hp, :こうげき, :ぼうぎょ, :とくこう, :とくぼう, :すばやさ
  attr_accessor :なまえ, :もちもの

  def initialize(なまえ:, hp:, こうげき:, ぼうぎょ:, とくこう:, とくぼう:, すばやさ:)
    @なまえ = なまえ
    @hp = hp
    @こうげき = こうげき
    @ぼうぎょ = ぼうぎょ
    @とくこう = とくこう
    @とくぼう = とくぼう
    @すばやさ = すばやさ
    @もちもの = nil
  end

  def ステータス
    <<-STATUS
      [#{@なまえ}のステータス]
      HP: #{@hp}
      こうげき: #{@こうげき}
      ぼうぎょ: #{@ぼうぎょ}
      とくこう: #{@とくこう}
      とくぼう: #{@とくぼう}
      すばやさ: #{@すばやさ}
      もちもの: #{@もちもの || 'なし'}
    STATUS
  end

  def もちもの(どうぐ)
    @もちもの = どうぐ
  end
end
```
```ruby
require_relative 'pokemon' #pokemon.rbを読み込んでいる。

class Pikachu < Pokemon # Pokemonクラスを継承している。「is-aの関係」 Pikachu is a Pokemon ピカチュウはポケモンの一種である。
  #ピカチュウのステータスを定数で定義している。
  DEFAULT_STATUS = {
    hp: 35,
    こうげき: 55,
    ぼうぎょ: 40,
    とくこう: 50,
    とくぼう: 50,
    すばやさ: 90,
  }

  #インスタンスの初期値を設定している。
  #「なまえ」DEFAULT_STATUSで定義しておらず、読み取り、書き込み可能にしている。Pikachu.new の引数で「なまえ」を受け取っている。
  def initialize(なまえ)
    super(
      なまえ: なまえ, #変更"可能"
      hp: DEFAULT_STATUS[:hp], #変更不可
      こうげき: DEFAULT_STATUS[:こうげき], #変更不可
      ぼうぎょ: DEFAULT_STATUS[:ぼうぎょ], #変更不可
      とくこう: DEFAULT_STATUS[:とくこう], #変更不可
      とくぼう: DEFAULT_STATUS[:とくぼう], #変更不可
      すばやさ: DEFAULT_STATUS[:すばやさ], #変更不可
    )
  end
end

モンスターボール = Pikachu.new('ピカチュウ')
モンスターボール.もちもの('でんきだま')
puts モンスターボール.ステータス #Pokemonクラスで定義した「ステータス」メソッド
```
実行結果
```ruby
      [ピカチュウのステータス]
      HP: 35
      こうげき: 55
      ぼうぎょ: 40
      とくこう: 50
      とくぼう: 50
      すばやさ: 90
      もちもの: でんきだま
```
## 3.ポリモーフィズムについて
次は、いよいよポケモンを戦わせます。
「たたかう」というメソッドを Pokemon クラスに定義します。
```ruby
#-------------------オブジェクト指向「継承」について---------
class Pokemon #親クラスのとなる Pokemonクラスを定義する。
  attr_reader :hp, :こうげき, :ぼうぎょ, :とくこう, :とくぼう, :すばやさ #読み取りのみを許可している（セッター）
  attr_accessor :なまえ, :もちもの #読み取りと書き込みを許可している（ゲッターとセッター）

  #ポケモンが持つ基本的なステータスを定義している。
  def initialize(なまえ:, hp:, こうげき:, ぼうぎょ:, とくこう:, とくぼう:, すばやさ:)
    @なまえ = なまえ
    @hp = hp
    @こうげき = こうげき
    @ぼうぎょ = ぼうぎょ
    @とくこう = とくこう
    @とくぼう = とくぼう
    @すばやさ = すばやさ
    @もちもの = nil
  end

  def ステータス #ポケモンのステータスを表示させるメソッドを定義
    <<-STATUS
      [#{@なまえ}のステータス]
      HP: #{@hp}
      こうげき: #{@こうげき}
      ぼうぎょ: #{@ぼうぎょ}
      とくこう: #{@とくこう}
      とくぼう: #{@とくぼう}
      すばやさ: #{@すばやさ}
      もちもの: #{@もちもの || 'なし'}
    STATUS
  end

  def もちもの(どうぐ)
    @もちもの = どうぐ
  end

  def たたかう(ポケモン)
    case ポケモン.class.to_s
      when "Pikachu"
        puts "#{@なまえ}の10まんボルト!!⚡️"
      when "Fusigidane"
        puts "#{@なまえ}のはっぱカッター!!🍃"
      when "Hitokage"
        puts "#{@なまえ}のひのこ!!🔥"
    end
  end
end
```
```ruby
require_relative 'pokemon' #pokemon.rbを読み込んでいる。

class Pikachu < Pokemon # Pokemonクラスを継承している。「is-aの関係」 Pikachu is a Pokemon ピカチュウはポケモンの一種である。
  #ピカチュウのステータスを定数で定義している。
  DEFAULT_STATUS = {
    hp: 35,
    こうげき: 55,
    ぼうぎょ: 40,
    とくこう: 50,
    とくぼう: 50,
    すばやさ: 90,
  }

  #インスタンスの初期値を設定している。
  #「なまえ」DEFAULT_STATUSで定義しておらず、読み取り、書き込み可能にしている。Pikachu.new の引数で「なまえ」を受け取っている。
  def initialize(なまえ)
    super(
      なまえ: なまえ, #変更"可能"
      hp: DEFAULT_STATUS[:hp], #変更不可
      こうげき: DEFAULT_STATUS[:こうげき], #変更不可
      ぼうぎょ: DEFAULT_STATUS[:ぼうぎょ], #変更不可
      とくこう: DEFAULT_STATUS[:とくこう], #変更不可
      とくぼう: DEFAULT_STATUS[:とくぼう], #変更不可
      すばやさ: DEFAULT_STATUS[:すばやさ], #変更不可
    )
  end
end

モンスターボール = Pikachu.new('ピカチュウ')
モンスターボール.たたかう(モンスターボール) #Pokemonクラスで定義した「たたかう」メソッド
```

実行結果
```ruby
ピカチュウの10まんボルト!!⚡️
```
「たたかう」メソッドは、case文で条件を分岐させています。
例として、３体のポケモンで条件分岐を作成しましたが、ポケモンは 1025 種類存在するので、1025 の条件分岐が必要となります。
そこで、「たたかう」メソッドは、サブクラスにもたせることにします。
```ruby
require_relative 'pokemon' #pokemon.rbを読み込んでいる。

class Pikachu < Pokemon # Pokemonクラスを継承している。「is-aの関係」 Pikachu is a Pokemon ピカチュウはポケモンの一種である。
  #ピカチュウのステータスを定数で定義している。
  DEFAULT_STATUS = {
    hp: 35,
    こうげき: 55,
    ぼうぎょ: 40,
    とくこう: 50,
    とくぼう: 50,
    すばやさ: 90,
  }

  #インスタンスの初期値を設定している。
  #「なまえ」DEFAULT_STATUSで定義しておらず、読み取り、書き込み可能にしている。Pikachu.new の引数で「なまえ」を受け取っている。
  def initialize(なまえ)
    super(
      なまえ: なまえ, #変更"可能"
      hp: DEFAULT_STATUS[:hp], #変更不可
      こうげき: DEFAULT_STATUS[:こうげき], #変更不可
      ぼうぎょ: DEFAULT_STATUS[:ぼうぎょ], #変更不可
      とくこう: DEFAULT_STATUS[:とくこう], #変更不可
      とくぼう: DEFAULT_STATUS[:とくぼう], #変更不可
      すばやさ: DEFAULT_STATUS[:すばやさ], #変更不可
    )
  end

  def たたかう
    puts "#{@なまえ}の10まんボルト!!⚡️"
  end
end

モンスターボール = Pikachu.new('ピカチュウ')
モンスターボール.たたかう
```
```ruby
ピカチュウの10まんボルト!!⚡️
```
今回は、Pikachu クラスしか作成していませんが、仮に Fusigidane クラス、Hitokage クラスがあれば、それぞれ「たたかう」メソッドを定義します。
それぞれのクラスに「たたかう」メソッドを定義することで、クラスごとに別々の技（振る舞い）をすることが可能となります。